#include<iostream>
#include <fstream>
#include<vector>
#include<stdio.h>
#include<cmath>
#include <iomanip>
#include <stdlib.h>
#include "Matrix algebra.h"

#pragma once

using namespace std;

vector<double> NonDiagonal(int N, int l);

int index(int i, int j, int N, int l); //по номеру элемента в исходной матрицы вычисл€ем его позицию в векторе L
							 //кладЄм элементы в ленту в следующем пор€дке : главна€ диагональ: i - j = 0 --> диагональ, наход€ща€с€ непосредственно под главной: i - j = 1 --> диагональ, наход€ща€с€ непосредственно над главной: i - j = -1 --> диагональ i - j = 2 -->диагональ i - j = -2 --> диагональ i - j = 3 и т.д.; элементы внутри диагонали -- сверху вниз
							 //это позвол€ет вывести простую формулу дл€ позиции первого элемента выбранной диагонали в векторе: дл€ главной диагонали эта позици€ есть 0; дл€ первой диагонали снизу эта позици€ есть число элементов главной диагонали, т.е. N; дл€ первой диагонали сверху это N + (N - 1); дл€ второй диагонали снизу это N + 2 * (N - 1); дл€ второй диагонали сверху это N + 2 * (N - 1) + (N - 2) и т.д.
							 //т.о., позици€ P(d) первого элемента d-ой диагонали (d = i - j) определ€етс€ формулой
							 //P(d) = N + 2*(N - 1) + 2*(N - 2) + ... + 2*(N - |d| + 1), если d > 0
							 //P(d) = N + 2*(N - 1) + 2*(N - 2) + ... + 2*(N - |d| + 1) + (N - |d|), если d < 0
							 //„тобы избавитьс€ от циклов, применим формулы суммы членов арифметической прогрессии
							 //P(d) соответствует позиции, которую в векторе займЄт первый элемент диагонали d. „тобы определить позицию следующих элементов диагонали, заметим, что при d < 0 первый элемент диагонали находитс€ в |d|-ом столбце, а при d > 0 -- в |d|-ой строке. ѕоэтому при определении номера элемента в векторе делаем сдвиг: на (j - |d| - 1) в первом случае и на (i - |d| - 1) во втором

class Lent //класс дл€ ленточных матриц
{
private: 
	int N; //пор€док 
	int l; //ширина ленты
	vector<double> L; //собственно элементы матрицы
public:
	double norm(); //максимум по модул€м недиагональных элементов -- нужно дл€ услови€ выхода в алгоритме якоби
	Lent(int N, int l);
	Lent(int N, int l, vector<double>& L); //создаЄм матрицу, если элементы ленты уже определены
	int get_N();
	int get_l();
	double get_element(int i, int j);
	vector<double> RowSum(); //п. (1.2)
	void print(); //вывод на консоль
	Vector Prod(Vector& X); //вектор, получающийс€ при умножении матрицы на вектор
	Lent(const Lent& copia);
	Lent& operator=(const Lent& C);
	Lent T(); //транспонирование
	friend Lent operator*(const Lent& A, const Lent& B);
	bool IfDiagDom();
};

Lent operator*(const Lent& A, const Lent& B);

vector<Vector> Generate_Lents(vector<Lent>& A, Vector& X, vector<double> Q, int N, int l);
